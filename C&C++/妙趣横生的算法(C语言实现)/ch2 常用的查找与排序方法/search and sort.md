## 选择排序：

选择排序的第i趟排序就是从序列的后n-i+1(i=1,2.....,n-1)个元素中选择一个最小(最大)的元素，并与第i个位置上的元素进行交换的过程。

```
void selectsort(keytype k[],int n){
  int i,j,min;
  keytype tmp;
  for(i=1;i<n-1;i++){
    min=i;
    for(j=i+1;i<=n;j++)
    	if(k[j]<k[min])
    		min=j;
    if(min!=i)
    {
      tmp=k[min];
      k[min]=k[i];
      k[i]=tmp;
    }
  }
}
```

## 冒泡排序

一个包含n个元素的序列要进行n-1趟的冒泡排序，第i趟冒泡排序将第1~n-i+1个元素中最大的元素交换到n-i+1个位置上。

由图可知，每趟都是从序列的第一位和第二位开始比较，如果是从大到小排序，那么每次比较如果前面比后面小，则进行交换，如此每次比较(可能交换)完以后在推进下刚才的第二个数跟第三个数的比较和交换，如此类推。

与快速排序的区别是，快速排序每次将剩下序列最大(最小的)交换到当前的有序序列的后一位，与冒泡的方式几乎是相反的操作。

改进：如果交换了若干趟以后，每次比较都没有发生交换，那么已经有序了，不用交换了，可以使用一个标志位进行相应记录。

![mark](http://otyq9b60e.bkt.clouddn.com/blog/170823/JdL2kmKIjF.gif)

```
void bubblesort(keytype k[],int n){
  int i,j,tmp,flag=1;
  for(i=1;i<=n-1&&flag==1;i++){
    flag=0;
    for(j=1;j<=n-i;j++){
      if(k[j]>k[j+1]){		//排序，使序列从小到大。可以理解成大的都往后翻滚
        tmp=k[j];
        k[j]=k[j+1];
        k[j+1]=tmp;
        flag=1;				//发生数据交换，值位
      }
    }
  }
}
```

